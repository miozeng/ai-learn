# 推荐系统

## 1.推荐引擎
个人认为推荐引擎就是，用户行为特征的获取（包括日志行为，用户特征等），获取之后（通过kafka spark等传递到HBase，这一步可以省略可以使用其他技术）然后进行推荐算法，然后反馈到前端用户这三个主要步骤，推荐引擎一般都分为
offline和online两部分，能offline的都offline做。

### 1.1 一致性哈希
在做缓存集群时，为了缓解服务器的压力，会部署多台缓存服务器，把数据资源均匀的分配到每个服务器上，分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。

数据分布通常有哈希分区和顺序分区两种方式

顺序分布：数据分散度易倾斜、键值业务相关、可顺序访问、不支持批量操作

哈希分布：数据分散度高、键值分布业务无关、无法顺序访问、支持批量操作
一致性哈希分区

一致性哈希的目的就是为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash 后会顺时针找到临接的存储节点存放。而当有节点加入或退 时，仅影响该节点在Hash环上顺时针相邻的后续节点。


优点

加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。

缺点

数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。

## 2推荐算法
输入参数是用户和item的各种属性和特征，个性化推荐算法一般会选用的信息包括（人口属性，地理属性，资产属性，兴趣属性）等等。经过推荐算法处理后，
返回一个按照用户喜好度排序的item列表。


### 2.1算法分类：
协调过滤推荐算法：
协调过滤是推荐算法中目前最主流的种类，花样繁多，在工业界已经有了很多广泛的应用。它的优点是不需要太多特定领域的知识，可以通过基于统计的机器学习算法来得到较好的推荐效果。最大的优点是工程上容易实现，可以方便应用到产品中。目前绝大多数实际应用的推荐算法都是协同过滤推荐算法。

基于内容的推荐算法：
这一类一般依赖于自然语言处理NLP的一些知识，通过挖掘文本的TF-IDF特征向量，来得到用户的偏好，进而做推荐。这类推荐算法可以找到用户独特的小众喜好，而且还有较好的解释性。
这跟NLP关联比较大，也推荐看看jieba分词

混合推荐算法：
通过多个推荐算法的结合，得到一个更好的推荐算法。比如通过建立多个推荐算法的模型，最后用投票法决定最终的推荐结果。混合推荐理论上不会比单一任何一种推荐算法差，但是使用混合推荐，
算法复杂度就提高了，在实际应用中有使用，但是并没有单一的协调过滤推荐算法，比如逻辑回归之类的二分类推荐算法广泛。

流行度推荐算法：
基于流行度的算法非常简单粗暴，类似于各大新闻、微博热榜等，根据PV、UV、日均PV或分享率等数据来按某种热度排序来推荐给用户。

#### 2.1.1协同过滤算法
协同过滤算法又分为两种一种是基于内存的，还有一种是基于模型的，
基于模型的推荐广泛使用的技术包括神经网络等学习技术、潜在语义 检索

### 2.2基于内存的协同过滤算法
基于内存的过滤算法又分为UCF和ICF

我们常用的距离计算方式有：

	欧几里得距离，马哈拉若距离，曼哈顿距离，切比雪夫距离，明可夫斯距离，海明距离，实际中运用较多的是欧几里得


我们常用的相似度计算方式有：

	余弦相似度（在基于物品近邻推荐算法中，最常用的一个相似度度量计算公式）；
	皮尔森相关系数（在基于用户近邻推荐算法中，常用的一种度量公式）；
	jaccard相似系数；tanimoto系数；对数似然相似度；互信息/信息增益，相对熵/KL散度；
	信息检索--词频-逆文档频率；词对相似度--点间互信息；


#### 2.2.1ICF
计算物品之间的相似度，根据物品的相似度和用户的历史行为给用户生成推荐列表
给用户推荐那些和他们之前喜欢的物品相似的物品，物品A和物品B的如果有大的相似度，那是因为喜欢物品A的用户也喜欢物品B

我们一般从每个人对于的物品建立同现矩阵，如有用户A,B ,C。商品a b c d .A喜欢商品a b 。B喜欢商品a c d .C喜欢商品a b c
那么A 的同现矩阵


| |a|b|c|d|
|:---|:---:|---:|---:|---:|  
|a| |1 | | |
|b|1 | | | |
|c| | | | |
|d| | | | |

然后将三个用户的同现矩阵相加得到相似度矩阵，然后使用公式计算相似度

1.计算物品相似度

#### 2.2.2 UCF
计算用户与用户之间的相似度，根据相似的用户对物品的喜好生成推荐列表
根据不同用户对相同商品或者内容的态度和偏好程度计算用户直接的关系，再相同喜好的用户间进行商品推荐
基于用户的最近邻推荐主要思想是：
首先，对输入的评分数据集和当前用户ID作为输入，找出与当前用户过去有相似偏好的其它用户，这些用户叫做对等用户或者最近邻；
然后，对当前用户没有见过的每个产品p，利用用户的近邻对产品p的评分进行预测；
最后，选择所有产品评分最高的TopN个产品推荐给当前用户。

如：
有用户A B C D E对商品1和商品2评分


| |商品1|商品2|
|---|---|---|
|A|3.3|6.5|
|B|5.8|2.6|
........

我们可以通过欧几里得距离计算用户A B C D E 两两之间的距离
也可以通过皮尔森相关系数计算用户两两直接的相关系数
距离越小或者相关系数越大则证明两者之间的关系越强越相似



#### 2.2.3 Item-CF和User-CF选择

user和item数量分布以及变化频率

	如果user数量远远大于item数量, 采用Item-CF效果会更好, 因为同一个item对应的打分会比较多, 而且计算量会相对较少
	如果item数量远远大于user数量, 则采用User-CF效果会更好, 原因同上
	在实际生产环境中, 有可能因为用户无登陆, 而cookie信息又极不稳定, 导致只能使用item-cf
	如果用户行为变化频率很慢(比如小说), 用User-CF结果会比较稳定
	如果用户行为变化频率很快(比如新闻, 音乐, 电影等), 用Item-CF结果会比较稳定
	
相关和惊喜的权衡

	item-based出的更偏相关结果, 出的可能都是看起来比较类似的结果
	user-based出的更有可能有惊喜, 因为看的是人与人的相似性, 推出来的结果可能更有惊喜
	
数据更新频率和时效性要求

	对于item更新时效性较高的产品, 比如新闻, 就无法直接采用item-based的CF, 因为CF是需要批量计算的, 在计算结果出来之前新的item是无法被推荐出来的, 导致数据时效性偏低;
	但是可以采用user-cf, 再记录一个在线的用户item行为对, 就可以根据用户最近类似的用户的行为进行时效性item推荐;
	对于像影视, 音乐之类的还是可以采用item-cf的

我们一般说：数据相关性在0.8-1 极强相关，0.6-0.8 强相关 0.4-0.6 一般相关
0.2-0.4 弱相关   0.0-0.2 极弱相关或者无相关

#### 2.2.4 练习：
使用UCF和ICF实现协同过滤
一步一步分析请看
[协同过滤-UCF&ICF](协同过滤-UCF&ICF.ipynb)
UCF代码情况
[ucf.py](ucf.py)
可以考虑不同的相似度和距离的方法来处理

### 2.3 基于模型的协同过滤算法
#### 2.3.1用关联算法做协同过滤
请参考ai/ai-learn/machinelearning/关联分析.ipynb
一般我们可以找出用户购买的所有物品数据里频繁出现的项集活序列，来做频繁集挖掘，找到满足支持度阈值的关联物品的频繁N项集或者序列。如果用户购买了频繁N项集或者序列里的部分物品，那么我们可以将频繁项集或序列里的其他物品按一定的评分准则推荐给用户，这个评分准则可以包括支持度，置信度和提升度等。
常用的关联推荐算法有Apriori，FP Tree和PrefixSpan。

#### 2.3.2 用聚类算法做协同过滤
用聚类算法做协同过滤就和前面的基于用户或者项目的协同过滤有些类似了。我们可以按照用户或者按照物品基于一定的距离度量来进行聚类。如果基于用户聚类，
则可以将用户按照一定距离度量方式分成不同的目标人群，将同样目标人群评分高的物品推荐给目标用户。基于物品聚类的话，则是将用户评分高物品的相似同类物品推荐给用户。
常用的聚类推荐算法有K-Means, BIRCH, DBSCAN和谱聚类

#### 2.3.3 用分类算法做协同过滤
　　　　如果我们根据用户评分的高低，将分数分成几段的话，则这个问题变成分类问题。比如最直接的，设置一份评分阈值，评分高于阈值的就是推荐，评分低于阈值就是不推荐，
我们将问题变成了一个二分类问题。常见的分类推荐算法有逻辑回归和朴素贝叶斯，两者的特点是解释性很强。

#### 2.3.4 用回归算法做协同过滤
　　　　用回归算法做协同过滤比分类算法看起来更加的自然。我们的评分可以是一个连续的值而不是离散的值，通过回归模型我们可以得到目标用户对某商品的预测打分。

　　　
#### 2.3.5.用矩阵分解做协同过滤
　　　　用矩阵分解做协同过滤是目前使用也很广泛的一种方法。由于传统的奇异值分解SVD要求矩阵不能有缺失数据，必须是稠密的，而我们的用户物品评分矩阵是一个很典型的稀疏矩阵，直接使用传统的SVD到协同过滤是比较复杂的。
　　　　目前主流的矩阵分解推荐算法主要是SVD的一些变种，比如FunkSVD，BiasSVD和SVD++。

#### 2.3.6.用神经网络做协同过滤
　　　　用神经网络乃至深度学习做协同过滤应该是以后的一个趋势。目前比较主流的用两层神经网络来做推荐算法的是限制玻尔兹曼机(RBM)。

#### 2.3.7.用图模型做协同过滤
　　　　用图模型做协同过滤，则将用户之间的相似度放到了一个图模型里面去考虑，常用的算法是SimRank系列算法和马尔科夫模型算法。

#### 2.3.8.用隐语义模型做协同过滤
　　　　隐语义模型主要是基于NLP的，涉及到对用户行为的语义分析来做评分推荐，主要方法有隐性语义分析LSA和隐含狄利克雷分布LDA。

#### 2.3.9练习课题：
用聚类算法，关联算法和神经网络完成推荐
 
 关联算法请参考 [关联分析](../machinelearning/关联分析.ipynb)

### 2.4 冷启动问题
在CF算法中，存在着冷启动的问题，主要包括：

	（1）如何向还没有任何物品评分的新用户进行推荐；
	（2）如何处理从未被评过分或者购买过的商品。
解决方案：

	（1）利用混合方法进行推荐，即利用额外的外部特征属性；对样本进行分类、聚类建模即可完成推荐；
	（2）结合基于用户的近邻推荐和基于物品的近邻推荐算法；
	（3）推荐Top10热门商品或者专门给定一个最近新加商品推荐列表。


### 2.5 调优方向
重新分析数据
重新选择算法



### 2.6 tensorflow
tf可视化
wide deep模型
tensorflow
深度学习


推荐系统手册
数据挖掘导论
构建大规模引擎


